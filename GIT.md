Основы GIT
==========

Базовые понятия
---------------

Состояния файлов под версионным контролем:

* Измененный (modified) - файл изменен, но еще не зафиксирован в базе данных;
* Подготовленный (staged) - измененный файл отмечен для включения в следующий коммит;
* Зафиксированный (comitted) - файл сохранен в локальной базе данных.

Рабочие области:

* Git directory (каталог git, место хранения метаданных и объектную базу данных вашего проекта);
* Working directory (рабочий каталог, извлечённая из базы копия определённой версии проекта);
* Staging area (область подготовленных файлов, файл находящийся в каталоге git и представляющий информацию о том, что должно войти в следующий коммит).

Установка
---------

Для операционной системы Debian/Ubuntu:

```bash
sudo add-apt-repository ppa:git-core/ppa
sudo apt-get update
sudo apt-get install git
```

Настройка
---------

### Файлы настроек

* `/etc/gitconfig` содержит значения, общие для всех пользователей системы и для всех их репозиториев (`git config --system`).
* `~/.gitconfig` хранит настройки конкретного пользователя (`git config --global`).
* `.git/config` конфигурационный файл репозитория (`git config`).

### Настройка имени пользователя

```bash
git config --global user.name "<имя>"
git config --global user.email <эл.почта>
```

### Настройка редактора

```bash
git config --global core.editor mcedit
```

### Настройка символов перевода строки (принудительное преобразование символа конца в строки в Unix-стиль)

```bash
git config --global core.autocrlf input
```

### Настройка вывода

```bash
git config core.quotepath false --global
```

### Утилита сравнения

```bash
git config --global merge.tool vimdiff
```

### Учитывать регистр в именах файлов/папок

В MacOS иногда при сохранении имени папки в нижнем регистре проявляется странный баг. При разворачивании репозитория под Linux название папки будет уже в другом регистре (первый символ с большой буквы). При этом в MacOS название папки отображается корректно (в нижнем регистре).

```bash
git config --global core.ignorecase false
```

### Настройки GPG

Для отключения подписи коммитов перейти в калог проекта и выполнить `git config commit.gpgsign false`.

Для включения подписи коммитов:

1. Создать GPG ключ;
2. Найти в списке нужный ключ и скопировать его Key ID (после `rsa4096/`), например `3AA5C34371567BD2` - `gpg --list-secret-keys --keyid-format LONG`;
3. Перейти в каталог проекта и настроить ключ:

```sh
git config user.signingkey 3AA5C34371567BD2
git config commit.gpgsign true
```

Важно, чтобы **email** из `git config user.email` совпадал с **email** GPG-ключа.

### Вывод настроек

```bash
git config --list
git config user.name
git config <ключ>
```

### Вызов справки

```bash
git help <команда>
git <команда> --help
```

Репозиторий
-----------

### Создание репозитория

```bash
git init
git init <каталог>
git init --bare <каталог> # репозиторий создаваемый как удаленный, не содержит рабочей директории с файлами
```

### Клонирование репозитория

```bash
git clone <url> <каталог>
git clone /home/username/project.git <каталог>
git clone git://user@somehost:port/~user/repository/project.git <каталог>
```

### Добавление файлов в репозиторий

Многофункциональная команда `git add` используется для добавления файлов в репозиторий, индексации изменений файлов, 
а также помечает файлы с конфликтом слияния как разрешенные.

```bash
git add <файл|каталог>
```

### Удаление файлов из репозитория

```bash
git rm <файл> # удаляет файл из индекса и диска
git rm -f <файл> # принудительное удаление (поможет удалить файл с проиндексированными изменениями еще не зафиксированный комиттом)
git rm --cached <файл> # удаляет файл из индекса, но не с диска
```

### Игнорирование файлов

В файле `.gitignore` можно указать список файлов или шаблонов неотслеживаемых файлов.
Исчерпывающий список примеров можно найти на сайте [Github](https://github.com/github/gitignore).

```bash
.idea
node_modules
*.py[co]
```

### Состояние репозитория

```bash
git status
git status -s # краткое отображение состояния (?? - неотслеживаемые, A - новые добавленные, M - модифицированные, MM - модифицированные после индексации)
git status -uno # без файлов не включенных в репозиторий
```

### Лог изменений

```bash
git log --oneline --graph --decorate # вывод в одну линию, деревом, с указанием веток
git log -1 # последняя запись в логе изменений
git log -p # дельта изменений
git log --word-diff # изменения на уровне слов, а не строк
git log --stat # выводит под каждым коммитом список изменённых файлов и количество изменений
git log --pretty=oneline # выводит каждый коммит в одну строку
git log --pretty="format:%h %an %ad %s" # выводит сокращенный хэш, имя автора, дату, комментарий
git log master..dev # показать какие коммиты из dev не слиты в master
```

### Просмотр изменений между файлами

```bash
git diff # изменения которые внесли, но еще не проиндексировали
git diff HEAD~1 HEAD # разница между последним и предпоследним коммитами
git diff --staged # узнать что войдет в новый коммит
```

### Фиксация изменений

    git commit -m <сообщение>
    git commit -a -m <сообщение> # добавляет все измененные файлы в индекс и делает коммит

### Отмена изменений

```bash
git commit --amend -m # изменяет последний коммит (меняет комментарий и хэш коммита)
git reset <хэш|файл>
git reset HEAD # сбросит состояние репозитория к последнему коммиту (будут забыты непроиндексированные изменения)
git reset HEAD <файл> # сброс индекса файла к состоянию последнего коммита (сам файл не меняется)
git checkout -- <файл> # сбрасывает файл к состоянию последнего коммита

git revert <хэш> # создает новый коммит отменяя указанный
git revert <хэш> -m <номер родителя по порядку> # используется при отмене коммита у которого более одного родителя, отменяет коммит в пользу указанного родителя коммита
```

### Перемещение и переименование файлов

    git mv <старый_файл> <новый_файл>


### Прятание

Часто возникает такая ситуация, что пока вы работаете над частью своего проекта, всё находится в беспорядочном состоянии,
а вам нужно переключить ветки, чтобы немного поработать над чем-то другим.
Проблема в том, что вы не хотите делать коммит с наполовину доделанной работой только для того,
чтобы позже можно было вернуться в это же состояние. Ответ на эту проблему — команда `git stash`.

Прятанье поглощает грязное состояние рабочего каталога, то есть изменённые отслеживаемые файлы и изменения в индексе,
и сохраняет их в стек незавершённых изменений, которые вы потом в любое время можете снова применить.

Для скрытия измененных файлов в хранилище:

    git stash

Список спрятанных состояний:

    git stash list

Восстановить спрятанное состояние:

    git stash apply # последнее созданное
    git stash apply stash@{2} # с указанным номером
    git stash apply --index # восстановить состояние и индекс

Удалить спрятанное состояние:

    git stash drop <спр.состояние>
    git stash drop stash@{2} # удалит спрятанное состояние stash@{2}

Удаленные репозитории
---------------------

Основной репозиторий по умолчанию имеет имя `origin`.
Получение данных из удаленного репозитория обозначется как `pull`, помещение данных как `push`.
Извлечение информации из удаленного репозитория обозначается как `fetch`

### Список удаленных репозиториев

    git remote
    git remote -v # список с информацией об URL для push и pull

### Добавление удаленного репозитория

    git remote add <название> <url>
    git remote add origin <url>

### Загрузить информацию из удаленного репозитория

Данная команда связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет.
После того как вы выполнили команду, у вас должны появиться ссылки на все ветки из этого удалённого проекта.
Теперь эти ветки в любой момент могут быть просмотрены или слиты.

Команда `fetch` забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент.
Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.

```bash
git fetch <уд.репозиторий> <ветка>
git fetch origin master
git fetch --all # извлечь данные со всех серверов
```

### Извлечь данные и слить их с локальной версией

Выполнение `git pull` извлекает (fetch) данные с сервера, с которого вы изначально склонировали, и автоматически пытается слить (merge) их с кодом, над которым вы в данный момент работаете.

    git pull <уд.репозиторий> <ветка>
    git pull origin master

### Отправить данные в удаленный репозиторий

    git push <уд.репозиторий> <ветка>
    git push origin master

По умолчанию команда `push` не отправляет в репозиторий новые метки (tags), для их отправки необходимо выполнить:

    git push <метка>
    git push v0.4

    git push --tags # отправить все метки

### Информация об удаленном репозитории

    git remote show <уд.репозиторий>
    git remote show origin

### Переименовать удаленный репозиторий

    git remote rename <старое имя> <новое имя>

### Удалить удаленный репозиторий

    git remote rm <уд.репозиторий>

Метки
-----

*Легковеслая метка* - это что-то весьма похожее на ветку, которая не меняется — это просто указатель на определённый коммит.

*Аннотированные метки* хранятся в базе данных Git'а как полноценные объекты. Они имеют контрольную сумму, содержат имя поставившего метку, e-mail и дату, имеют комментарий и могут быть подписаны и проверены с помощью GNU Privacy Guard (GPG).
Обычно рекомендуется создавать аннотированные метки, чтобы иметь всю перечисленную информацию; но если вы хотите сделать временную метку или по какой-то причине не хотите сохранять остальную информацию, то для этого годятся и легковесные метки.

### Создание метки

Создание легковеслой метки:

    git tag <метка>
    git tag v0.0.1

Создание аннотированной метки:

    git tag -a <метка> -m <комментарий>
    git tag -a v0.0.1 -m 'My first version'

Выставить легковеслую метку для определенного коммита:

    git tag <метка> <хэш коммита>
    git tag v0.4 9fceb02

### Просмотр меток репозитория

    git tag

Для просмотра меток по шаблону используйте команду:

    git tag -l '<шаблон поиска>'
    git tag -l 'v1.4.2.*'

Ветки
-----

Ветка в Git — это просто легковесный подвижный указатель на один из этих коммитов. Ветка по умолчанию в Git называется `master`.
Когда вы создаёте коммиты на начальном этапе, вам дана ветка `master`, указывающая на последний сделанный коммит.
При каждом новом коммите она сдвигается вперёд автоматически.

В GIT существует специальный указатель `HEAD`, который ссылается на ветку на которой вы находитесь.

### Создать ветку

    git branch <имя ветки> # создаст новую ветку, но не переключит на нее репозиторий

    git branch dev # создать ветку dev
    git checkout dev # переключится на ветку dev

    git checkout -b <ветка> # создать ветку и переключить на нее репозиторий

### Удалить ветку

    git branch -d <ветка>
    git branch -D <ветка> # удалить неслитую ветку и потерять наработки

### Отобразить существующие ветки

    git branch # символ * указывает на текущую ветку
    git branch -v # список веток с последним коммитом на них
    git branch --merged # слитые ветки
    git branch --no-merged # не слитые ветки

### Переключение между ветками

    git checkout <ветка>

### Слияние изменений между ветками

    git checkout <ветка в которую сливаем изменения>
    git merge <ветка из которой сливаем изменения>

    git checkout master # переключится на ветку master
    git merge dev # в ветку master будут слиты изменения из ветки dev

### Разрешение конфликтов слияния

Слияние не всегда проходит гладко, если в репозиторий отправляются изменения одного и того же файла,
сделанные разными разработчиками может возникнуть конфликт слияния. GIT известит о конфликте следующим сообщением `'Automatic merge failed; fix conflicts and then commit the result.'`.

Ваши действия при конфликте слияния:

1. Определить в каких файлах произошел конфликт слияния (обычно они перечисляются при выполнении операции `git merge`);
2. Изменить конфликтующие файлы, убрав метки `<<<<<<< HEAD`, `=======`, `>>>>>>>` и оставив нужные данные;
3. Добавить измененные файлы в индекс `git add <файл>`;
4. Выполнить коммит измененных файлов `git commit`.

### Применение перемещения при объединении изменений

Расспространена ситуация когда вы создаете новую ветку (например dev) от основной ветки (например master) и создаете в ней коммиты.
В это время кто-то завершив работу обновляет основную ветку (master).
При этом возникает развилка, ваши коммиты уже не получится слить с основной веткой без создания нового коммита от слияния двух веток.
Команда `rebase` выполняет действия по перемещению коммитов в вашей неосновной ветке (dev),
в рузультате чего появляется возможность выполнить слияние без создания дополнительного коммита.

Ваши действия при перемещении:

1. Перейти в неосновную ветку (например dev) `git checkout dev`;
2. Выполнить перемещение `git rebase master` (изменится хэш коммитов в ветке dev, ветка master останется в исходном состоянии);
3. (При конфликте перемещения) Разрешить конфликты, убрав метки `<<<<<<< HEAD`, `=======`, `>>>>>>>` и оставив нужные данные;
4. (При конфликте перемещения) Добавить измененные файлы в индекс `git add <файл>`;
5. (При конфликте перемещения) Подтвердить разрешение конфликтов `git rebase --continue`
6. (Rebase не выполняет слияние веток автоматически) Выполнить слияние веток master с dev, оно не создаст новый коммит `git checkout master`, `git merge dev`.

Отменить перемещение можно командой `git rebase --abort`.

**Не перемещайте коммиты, которые вы уже отправили в публичный репозиторий.**

### Перемещение ветки ответвленной от другой ветки

    git rebase --onto <основная ветка> <ветка А> <ветка Б (ответвленная от ветка А)>
    git rebase --onto master dev1 dev2
    
### Перемещение определенных коммитов

```bash
# Переместить в текущую ветку комммиты которые есть в topic, но нет в dev.
git cherry-pick dev..topic
```

### Правка сообщений нескольких коммитов

Команда `rebase` позволяет выполнить переименование комментариев к коммитам (с изменением хэша).

    git rebase -i HEAD~4 # открыть для правки

В открывшемся редакторе указать напротив каждой строчки коммита команду `reword`.

### Удаленные ветки

Удалённые ветки — это ссылки на состояние веток в ваших удалённых репозиториях.
Это локальные ветки, которые нельзя перемещать; они двигаются автоматически всякий раз, когда вы осуществляете связь по сети.
Удалённые ветки действуют как закладки для напоминания о том, где ветки в удалённых репозиториях находились во время последнего подключения к ним.

Удаленные ветки обычно имеют имя вида `<уд.репозиторий>/<ветка>`.

Локальная ветка связанная с удаленной веткой называется *отслеживаемой веткой*.
Примером отслеживаемой ветки является ветка `origin/master` которая создается при клонировании репозитория.

Два способа создание отслеживаемой ветки:

    git checkout -b <имя ветки> <уд.ветка>
    git checkout -b dev origin/dev # создаст отслеживаемую ветку dev

    git checkout --track <уд.ветка>
    git checkout --track origin/dev # создаст отслеживаемую ветку dev

### Удаление удаленной ветки на сервере

```bash
git push <уд.репозиторий> --delete <ветка>
```

### Слежение за ветками

Отслеживаемая ветка это локальная ветка напрямую связанная с удаленной.
При выполнении команд `git pull` и `git push` система Git автоматически понимает с какой удаленной веткой необходимо работать.

```bash
git checkout -b <ветка> <имя уд.сервера>/<ветка> # создать и сделать ветку отслеживаемой
git checkout --track <имя уд.сервера>/<ветка> # создать и сделать ветку отслеживаемой
git branch -u <имя уд.сервера>/<ветка> # сделать ветку отслеживаемой
git branch -vv # список отслеживаемых веток
```


Полезные советы по работе с GIT
-------------------------------

### Автоподсказка при вводе команд

При вводе команды под Linux нажать два раза клавишу <Tab>. На экране отобразится список подсказок для ввода возможной команды.

### Псевдонимы команд

```bash
git config --global alias.<псевдоним> '<команда>'
git config --global alias.co 'checkout'

git config --global alias.lg 'log --oneline --graph --pretty=format:"%C(bold yellow)(%p) %h%C(reset)%C(bold cyan)%d%C(reset) %C(cyan)[%cn]%C(reset) %C(magenta)%cd%C(reset)%C(white) - %s" --date=format:"%d.%m.%Y %H:%M"'
git config --global core.editor "'C:/Program Files/Sublime Text 3/subl.exe' -w"
```
### Пустой коммит

Может пригодиться если нужно перезапустить сборку CI.

```bash
git commit --allow-empty -m 'it works!'
```

### Worktree

Git поддерживает множественные рабочие деревья из одного репозитория.

```bash
git worktree add ../папка_для_ветки имя_ветки
// или если ветки ещё нет
git worktree add -b имя_ветки ../папка_для_ветки origin/main

// Список всех папок
git worktree list

// Удалить ненужную папку
git worktree remove путь/до/папки
```
